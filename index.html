<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ðŸ’– Kalp Animasyonu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
            cursor: pointer;
            will-change: transform;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            z-index: 10;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: fadeIn 2s ease-in-out;
            pointer-events: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255, 20, 147, 0.25) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: pulse 4s ease-in-out infinite;
            will-change: transform, opacity;
        }

        @keyframes pulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.25;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.15);
                opacity: 0.5;
            }
        }

        .fps {
            position: absolute;
            top: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="glow"></div>
    <div class="info">Seninle konuÅŸunca kalbim bÃ¶yle oluyor âœ¨</div>
    <div class="fps" id="fps">FPS: 60</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { 
            alpha: false,
            desynchronized: true
        });
        
        // Cihaz tespiti
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = isMobile && (navigator.hardwareConcurrency <= 4 || window.innerWidth < 768);
        
        // Dinamik ayarlar
        const settings = {
            particleCount: isLowEnd ? 500 : isMobile ? 800 : 1000,
            trailEnabled: !isLowEnd,
            connectionsEnabled: !isLowEnd,
            glowLayers: isLowEnd ? 1 : isMobile ? 2 : 3,
            maxFPS: isMobile ? 45 : 60
        };

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Particle {
            constructor(x, y, targetX, targetY, index) {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.targetX = targetX;
                this.targetY = targetY;
                this.index = index;
                this.size = Math.random() * 2 + 1.5;
                this.speedX = 0;
                this.speedY = 0;
                
                this.colorIndex = Math.floor(Math.random() * colorPalette.length);
                this.color = colorPalette[this.colorIndex];
                
                this.opacity = 0;
                this.fadeInSpeed = Math.random() * 0.015 + 0.01;
                this.reachedTarget = false;
                this.oscillation = Math.random() * Math.PI * 2;
                this.oscillationSpeed = Math.random() * 0.04 + 0.02;
                this.glowIntensity = Math.random() * 0.5 + 0.5;
                
                if (settings.trailEnabled) {
                    this.trail = [];
                    this.maxTrailLength = 5;
                }
            }

            update(time) {
                if (settings.trailEnabled && this.opacity > 0.5) {
                    if (this.trail.length === 0 || Math.hypot(this.trail[this.trail.length - 1].x - this.x, this.trail[this.trail.length - 1].y - this.y) > 3) {
                        this.trail.push({ x: this.x, y: this.y });
                        if (this.trail.length > this.maxTrailLength) {
                            this.trail.shift();
                        }
                    }
                }

                if (time < 7000) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distanceSq = dx * dx + dy * dy;

                    if (distanceSq > 4) {
                        const distance = Math.sqrt(distanceSq);
                        const ease = Math.min(distance / 100, 1);
                        const force = distance * 0.00012 * ease;
                        
                        this.speedX += dx * force;
                        this.speedY += dy * force;
                        
                        this.speedX *= 0.92;
                        this.speedY *= 0.92;
                        
                        this.x += this.speedX;
                        this.y += this.speedY;
                    } else {
                        this.reachedTarget = true;
                        this.x = this.targetX;
                        this.y = this.targetY;
                    }

                    if (this.opacity < 1) {
                        this.opacity = Math.min(1, this.opacity + this.fadeInSpeed);
                    }
                } else {
                    this.reachedTarget = true;
                    this.oscillation += this.oscillationSpeed;
                    
                    const oscillateX = Math.sin(this.oscillation) * 2;
                    const oscillateY = Math.cos(this.oscillation * 1.3) * 2;
                    
                    this.x = this.targetX + oscillateX;
                    this.y = this.targetY + oscillateY;

                    this.glowIntensity = 0.6 + Math.sin(time * 0.002 + this.oscillation) * 0.3;
                }
            }

            draw() {
                if (settings.trailEnabled && this.trail && this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const alpha = (i / this.trail.length) * this.opacity * 0.2;
                        ctx.strokeStyle = this.color.trail.replace('ALPHA', alpha);
                        ctx.lineWidth = this.size * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                        ctx.lineTo(this.trail[i + 1].x, this.trail[i + 1].y);
                        ctx.stroke();
                    }
                }

                for (let i = settings.glowLayers; i > 0; i--) {
                    const glowSize = this.size * (2 + i * 1.5);
                    const glowOpacity = (this.opacity * this.glowIntensity) / (i * 2.5);
                    
                    ctx.fillStyle = this.color.glow.replace('ALPHA', glowOpacity);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = this.color.core.replace('ALPHA', this.opacity);
                ctx.shadowBlur = isMobile ? 8 : 15;
                ctx.shadowColor = this.color.shadow;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        const colorPalette = [
            {
                core: 'rgba(255, 20, 147, ALPHA)',
                glow: 'rgba(255, 20, 147, ALPHA)',
                trail: 'rgba(255, 20, 147, ALPHA)',
                shadow: 'rgba(255, 20, 147, 0.8)'
            },
            {
                core: 'rgba(255, 105, 180, ALPHA)',
                glow: 'rgba(255, 105, 180, ALPHA)',
                trail: 'rgba(255, 105, 180, ALPHA)',
                shadow: 'rgba(255, 105, 180, 0.8)'
            },
            {
                core: 'rgba(255, 0, 127, ALPHA)',
                glow: 'rgba(255, 0, 127, ALPHA)',
                trail: 'rgba(255, 0, 127, ALPHA)',
                shadow: 'rgba(255, 0, 127, 0.8)'
            },
            {
                core: 'rgba(220, 20, 60, ALPHA)',
                glow: 'rgba(220, 20, 60, ALPHA)',
                trail: 'rgba(220, 20, 60, ALPHA)',
                shadow: 'rgba(220, 20, 60, 0.8)'
            },
            {
                core: 'rgba(255, 69, 0, ALPHA)',
                glow: 'rgba(255, 69, 0, ALPHA)',
                trail: 'rgba(255, 69, 0, ALPHA)',
                shadow: 'rgba(255, 69, 0, 0.8)'
            },
            {
                core: 'rgba(148, 0, 211, ALPHA)',
                glow: 'rgba(148, 0, 211, ALPHA)',
                trail: 'rgba(148, 0, 211, ALPHA)',
                shadow: 'rgba(148, 0, 211, 0.8)'
            }
        ];

        function createHeartShape(centerX, centerY, scale) {
            const points = [];
            const detail = settings.particleCount;
            const step = (Math.PI * 2) / detail;
            
            for (let i = 0; i < detail; i++) {
                const t = i * step;
                
                const sinT = Math.sin(t);
                const cosT = Math.cos(t);
                const x = 16 * sinT * sinT * sinT;
                const y = -(13 * cosT - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                
                points.push({
                    x: centerX + x * scale,
                    y: centerY + y * scale
                });
            }
            
            return points;
        }

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = Math.min(canvas.width, canvas.height) / 40;
        const heartPoints = createHeartShape(centerX, centerY, scale);

        const particles = heartPoints.map((point, i) => 
            new Particle(0, 0, point.x, point.y, i)
        );

        let startTime = Date.now();
        let fps = 60;
        let frameCount = 0;
        let lastFpsUpdate = Date.now();
        const frameInterval = 1000 / settings.maxFPS;
        let lastDrawTime = 0;

        function animate(currentTime) {
            const elapsed = currentTime - lastDrawTime;
            if (elapsed < frameInterval) {
                requestAnimationFrame(animate);
                return;
            }
            lastDrawTime = currentTime - (elapsed % frameInterval);

            const time = Date.now() - startTime;
            
            frameCount++;
            if (time - lastFpsUpdate > 1000) {
                fps = Math.round(frameCount * 1000 / (time - lastFpsUpdate));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastFpsUpdate = time;
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < particles.length; i++) {
                particles[i].update(time);
                particles[i].draw();
            }

            if (settings.connectionsEnabled && time > 7000) {
                ctx.lineWidth = 0.5;
                for (let i = 0; i < particles.length; i += 3) {
                    const particle = particles[i];
                    const nextParticle = particles[(i + 1) % particles.length];
                    
                    const dx = particle.x - nextParticle.x;
                    const dy = particle.y - nextParticle.y;
                    const distanceSq = dx * dx + dy * dy;
                    
                    if (distanceSq < 900) {
                        const alpha = 0.1 * particle.opacity * (1 - distanceSq / 900);
                        ctx.strokeStyle = `rgba(255, 105, 180, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(particle.x, particle.y);
                        ctx.lineTo(nextParticle.x, nextParticle.y);
                        ctx.stroke();
                    }
                }
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                const newCenterX = canvas.width / 2;
                const newCenterY = canvas.height / 2;
                const newScale = Math.min(canvas.width, canvas.height) / 40;
                const newHeartPoints = createHeartShape(newCenterX, newCenterY, newScale);
                
                particles.forEach((particle, i) => {
                    particle.targetX = newHeartPoints[i].x;
                    particle.targetY = newHeartPoints[i].y;
                });
            }, 250);
        });

        let interactionTimeout;
        const handleInteraction = (e) => {
            e.preventDefault();
            
            const touch = e.touches ? e.touches[0] : e;
            const mouseX = touch.clientX;
            const mouseY = touch.clientY;
            
            if (interactionTimeout) return;
            interactionTimeout = setTimeout(() => {
                interactionTimeout = null;
            }, 16);
            
            const maxDistance = isMobile ? 80 : 100;
            const maxDistanceSq = maxDistance * maxDistance;
            
            for (let i = 0; i < particles.length; i += (isMobile ? 2 : 1)) {
                const particle = particles[i];
                const dx = mouseX - particle.x;
                const dy = mouseY - particle.y;
                const distanceSq = dx * dx + dy * dy;
                
                if (distanceSq < maxDistanceSq) {
                    const distance = Math.sqrt(distanceSq);
                    const force = (maxDistance - distance) / maxDistance;
                    const angle = Math.atan2(dy, dx);
                    
                    particle.x -= Math.cos(angle) * force * (isMobile ? 2 : 3);
                    particle.y -= Math.sin(angle) * force * (isMobile ? 2 : 3);
                    
                    if (!isMobile) {
                        particle.glowIntensity = 1 + force * 0.5;
                    }
                }
            }
        };

        canvas.addEventListener('mousemove', handleInteraction, { passive: false });
        canvas.addEventListener('touchmove', handleInteraction, { passive: false });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseX = touch.clientX;
            const mouseY = touch.clientY;
            
            particles.forEach((particle, i) => {
                if (i % 3 !== 0) return;
                
                const dx = mouseX - particle.x;
                const dy = mouseY - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 150) {
                    const angle = Math.atan2(dy, dx);
                    const force = (150 - distance) / 150 * 8;
                    
                    particle.speedX -= Math.cos(angle) * force;
                    particle.speedY -= Math.sin(angle) * force;
                }
            });
        }, { passive: false });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                settings.maxFPS = 30;
            } else {
                settings.maxFPS = isMobile ? 45 : 60;
                startTime = Date.now();
            }
        });
    </script>
</body>
</html>
